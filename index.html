<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet"
	  href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/default.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>
  </head>
  <body>

    <h1> Custom Error in Rust </h1>
    <pre>
      <code class="rust">
macro_rules! error_impl {
    ($err_struct:ident, $msg: expr) => (
        impl std::fmt::Display for $err_struct {
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                write!(f, "{}", $msg)
            }
        }

        impl std::error::Error for $err_struct {
            fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                None
            }
        }
    );
}

#[derive(Debug, Copy, Clone)]
pub struct NotAsciiError;
error_impl!(NotAsciiError, "Not Valid Ascii");


      </code>
    </pre>

    <h1> Execute os command (with exit status and command output) </h1>
    <pre>
      <code class="erlang">
os_cmd(Command) ->
  Port = open_port({spawn, Command}, [stream, in, eof, hide, exit_status]),
  capture_cmd_output(Port, []).

capture_cmd_output(Port, Sofar) ->
  receive
    {Port, {data, Bytes}} ->
      capture_cmd_output(Port, [Sofar|Bytes]);

    {Port, eof} ->
      Port ! {self(), close},
      receive
        {Port, closed} ->
          true
      end,
      receive
        {'EXIT',  Port,  _} ->
          ok
      after 1 ->              % force context switch
          ok
      end,
      ExitCode =
        receive
          {Port, {exit_status, Code}} ->
            Code
        end,
      {ExitCode, lists:flatten(Sofar)}
  end.
      </code>
    </pre>
  </body>

  <script>hljs.initHighlightingOnLoad();</script>
</html>
